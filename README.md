# Development Log: Custom TCP/IP Stack & SDN Controller

### 2026.02.07
* **Research and Requirements**: Laid down the project expectations and research goals.
* **Ultimate Objective**: Develop a custom minimal TCP/IP stack and SDN controller functions for the NUCLEO H753ZI development board.
* **Software Acquisition**: STM32CubeMX and STM32CubeIDE will be used for the development process.
* **Study**: Read through the development board's datasheet and familiarized myself with unknown concepts.
* **Exploration**: Explored the possibilities within STM32CubeMX.
* **Documentation**: Acquired essential documents: Reference Manual and HAL Driver Manual.

### 2026.02.08
* **First Milestone**: Receive Ethernet frames and immediately output them via UART.
* **Project Base Structure**: Created the basic structure using STM32CubeMX.
    * Enabled Ethernet in RMII mode.
* **MPU Configuration**:
    * Enabled CPU I-Cache and CPU D-Cache. Based on the PM0253 Programming Reference, this enables caching globally.
    * Found a dedicated document (AN4839) regarding caching.
    * Created a 256KB MPU region for Ethernet.
    * **Memory Architecture**: According to the diagram on page 105 of the Reference Manual, there are 3 domains. The ETH peripheral is located in **Domain 2**, meaning the ETH DMA can only access **SRAM1, 2, and 3** memory areas.
    * **Addressing**: Based on the table on page 131, this area starts at **0x30000000**. The 256KB region ends in SRAM2, which should be perfectly fine.
    * **Cache Coherency**: Disabled caching for this specific region to avoid errors. Set **TEX to 1** to fully disable caching. (Note: It is still unclear why there are separate TEX and cache disable options, but it should work).
* **Diagnostics**:
    * Enabled USART3 with default settings.
    * Configured DMA for USART3_TX with "Memory to Peripheral" direction.
    * **NVIC**: Raised EthernetU priority above USART3 in the interrupt controller to ensure stability.

### 2026.02.09
* **Project Review**: Analyzed the file structure and interpreted the purpose of various files.
* **Version Control**: Created a GitHub repository and saved the state with the message: *"Initial commit - STM32H7 SDN Project start"*.
* **Driver Research**: Consulted HAL User Manual section 24.2 (p. 332) "How to use ETH driver".
    * Realized after an hour of struggle that the manual I was reading was for **F7** chips (`stm32f7xx_hal_eth.h`) instead of the **H7** which I am using.
* **Correct Documentation**: Finally located the correct H7 HAL document. It's confusing why it wasn't placed under the STM32H743/753 PDF Documentation tab like the others.
* **HAL ETH Generic Driver (p. 420) / How to use (p. 431)**:
    1. Declare `ETH_HandleTypeDef heth;` (Already auto-generated by MX).
    2. Fill Init parameters in `heth` handle (Already auto-generated by MX).
    3. Call `HAL_ETH_Init()` to initialize MAC and DMA (Already auto-generated by MX).
    4. **Low-level resources (MSP)**:
        * Enable clocks: `__HAL_RCC_ETH1MAC_CLK_ENABLE()`, `TX`, and `RX`.
        * Initialize GPIO clocks and Ethernet pinout.
        * Configure Ethernet NVIC interrupt (Interrupt mode).
        * (These were also auto-generated by MX based on my clock and pin settings).
    5. **Reception Mode**: Since data reception is asynchronous, I chose **Method B**: `HAL_ETH_Start_IT()`. This enables end-of-transfer interrupts, and `HAL_ETH_RxCpltCallback()` will execute when a packet is received.

### 2026.02.10
* **Implementation**: Started implementing `HAL_ETH_RxCpltCallback()`, which is called whenever the ETH DMA finishes copying.
* **DMA**: Using the pre-defined DMA controller in MX with the `HAL_UART_Transmit_DMA(&huart3, source , Length)` function.
* **Deep Dive**: Studying the Ethernet Descriptor structure (Reference Manual p. 2909).
*  I am learning about memory management and trying to understand how .ld files and their pregenerated content work.
*  I made an ETH memory section in the linker script, for now 64kb should be sufficient. Created necessary section for the ETH HAL driver and contained necessary tags:  `.RxDescripSection` and `.TxDescripSection`

### 2026.02.11
* **Status**: USART is tested and functional. I will continue working on the basics ETH configuration.
* **Understanding the ETH data structures**:
    * Re-reading the DMA driver description and trying to understand the pregenerated content fully, sometimes i am peeking into the HAL driver code. I am learning so much about the C language during it.
    * **ETH_HandleTypeDef analysis**: This contains everything, including the discriptor lists: `TxDescList`, `RxDescList`, and core functions and data structures: `HAL_ETH_Init`, `Start`, `Transmit`,            `ReadData`, `GetState`.
      * **heth.Instance = ETH**: The *Instance field is required to be set to the base ETH register address. I checked the ETH base address definition in the HAL driver: `#define ETH ((ETH_TypeDef*)ETH_BASE)`. `ETH_TypeDef` contains the registers cast to the base address.
      * **heth.Init**: This field contains a `ETH_InitTypeDef` struct. This structure contains the initial configuration:
        * ***MACAddr**: The pointer to the MAC address, must be an array of 6 bytes
        * **MediaInterface**: Selects the interface. This board has two options: MII or RMII
        *  ***TxDesc** **and** ***RxDesc**: Points to the address of the first discriptor
        *  **RxBuffLen**: Specifies the length of the receiving buffer.
      * **HAL_ETH_MspInit**: Specifies the GPIO pin outlet, configures the clocks and the NVIC for callbacks interuption.
      * **HAL_ETH_Start_IT(heth)**: This function starts the MAC and DMA transmission and reception. When the DMA copied the frame into the memory, it will call the HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth) function.
        
### 2026.02.12
* The ETH config is set up correctly as per the HAL driver manual. Although it's not working yet, I'm trying to make sense of it using debug mode.
* I found the probable cause all descriptor values are zero.
* <img width="911" height="663" alt="image" src="https://github.com/user-attachments/assets/3ae08dc1-b57f-4342-b8d3-226a92c7ebed" />
* Since i don't see any other option in the hal driver i will try to fill up the descriptors myself, if i understand it well i have to fill up the desc0 with the destination address, and flip the own bit to 1.
* I created a buffer and manually set the first descriptor's desc0 field with the destination address. I flipped the desc3 OWN bit to 1, but it still isn't working.
* I ran the HAL_ETH_GetError(&heth) and the HAL_ETH_GetDMAError(&heth) to get more information, i am researching about the received erorros:  0x8, 0x1002
### 2026.02.13
*Finally found the error the descriptor addresses were to small (24byte), and the hardware tried to read 32-byte pieces.
*<img width="696" height="595" alt="image" src="https://github.com/user-attachments/assets/aacd04c6-9f97-454b-95f2-187e694145e4" />
*I am sure there is a fancier solution for this, but i just added a 2-bytes padding to the ETH_DMADescTypeDef structure maybe i will come across with some better sulution later
*Finnaly the ETH is working fine i am able to recive frames and send log informations throught usart
*I had to implement a temporary filter to my own pc mac address for testing because my ONT device spamming huge ammount of broadcast message (multiple/sec)
*<img width="1137" height="497" alt="image" src="https://github.com/user-attachments/assets/67988fb7-1182-44c4-a085-ccbb05586319" />

